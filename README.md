### Wait and Notify
1. 在调用wait对象的时候，线程必须持有被调用对象的锁，当调用wait方法后，线程会释放掉该对象的锁。在调用Thread类的sleep方法时，线程是不会释放掉
线程的锁的 `WaitNotifyDemo`
   1. 当调用wait时，首先需要确保调用了wait方法的线程已经持有了对象的锁。
   2. 当调用wait方法后，该线程就会释放掉对象的锁，从而进入等待状态（wait set）。
   3. 当线程调用wait 进入等待状态（wait set）后，它可以等待其他线程调用相同对象notify或者notifyAll方法来时的自己被唤醒。
   4. 一旦一个线程被其他线程唤醒后，该线程就会与其他线程一起竞争 这个对象的锁，只有该线程获得了这个对象的锁后，线程才会继续向下执行。
   5. 调用wait方法的代码片段需要放入 synchronized方法，或者synchronized 代码段。这样才能够保证线程线程在调用wait方法前已经获取到了对象的锁。
   6. 当调用对象的notify方法是，他会随机唤醒等待集合（wait set） 上的任何一个线程，当一个线程被唤醒之后，他会与其他线程一起竞争对象的锁。
   7. 当调用对象的notifyAll方法时，他会唤醒该对象的大等待集合（wait set）上的所有线程。这些线程线程被唤醒后。
   8. 在某一时间，只有唯一的一个线程能够拥有对象锁
   9. 在使用synchronized关键字来修饰代码块儿的时候，字节码层面上视同过MonitorEnter和MonitorExit来是想锁的获取与释放的
   10. 当线程进入MonitorEnter指令后，线程会持有monitor对象，退出Monitor指令后，线程将会释放monitor对象，
   11. 对于Synchronized关键字修饰的方法，并没有出现monitorEnter指令和monitorExit指令，JVM使用了ACC_SYNCHRONIZED 访问标志来区分一个方法
是否为同步方法，当方法被调用时，调用指令会检查该方法是否拥有ACC_SYNCHRONIZED标志，那么执行线程会先持有方法所在对象的Monitor对象，然后再去执行方法
体，再该方法执行期间，其他任何线程均无法获得到这个monitor对象，当线程执行完这个方法是，线程将释放这个Monitor对象。
   12. JVM 中的同步是基于进入与退出监视器对象（管程） Monitor对象来实现的。
   13. 每一个对象实例实例都会有一个Monitor对象，Monitor对象回和java对象一同创建并销毁，Monitor对象是由C++来实现的。
   14. 多个线程同时访问一段同步代码时，这些线程会放到一个EntryList中，处于阻塞状态的线程都会被放到这个list中， 接下来，当线程获取对象monitor的
时，Monitor时依赖于底层操作系统的mutex lock来实现互斥的，线程获取mutex成功，则会持有mutex，这时其他线程就无法再获取到该mutex。
   15. 如果线程调用类wait方法，那么该线程就会释放掉锁持有的mutex，那么该线程会进入到waitset集合，等待下一次被线程调用notify/notifyAll唤醒。
如果但钱线程顺利执行完毕，那么他会释放掉锁持有mutex。
   16. 同步锁再这种实现方式中，因为monitor是依赖于底层的操作系统实现，这就存在用户态和内核态之间的切换，这样就会增加性能 的开销， 通过对象
互斥的概念来保证共享数据操作的完整性， 每个对象都 对应一个可称为【互斥锁】的标记。这个标记用于保证再任何时刻，只能有一个线程访问该对象。
   17. 那些处于EntryList 与 WaitSet中的线程均处于阻塞状态，阻塞操作有操作系统来完成，再linux 下通过pthread_mutex_lock函数实现的，
线程被阻塞后会进入内核调度状态，这会导致用户态与内核态来回切换，严重影响锁的性能。
   18. 解决上面的问题的办法是使用自旋（spin），其原理是：当发生对Monitor的争用时，若Owner能够在很短的时间释放掉锁，则那些正在争用的线程可以稍微等待一下
（即所谓的自旋）， 若Owner线程释放锁后，争用线程 可能立即获取到锁，从而避免了系统阻塞。不过当Owner运行的时间 超过了临界值后，争用一段时间后
仍然无法获取到锁，这是争用线程会进入停止自旋，进入阻塞状态。总体思想是，先自旋，不成功在进行阻塞。尽量减少阻塞的可能性，对那些执行时间很短的代码块儿来说，
对那些执行时间很短的代码块儿来说，有极大的新能提升。显然，自旋在多处理器上才有意义。
   19. 互斥锁的属性
       1. PTHREAD_MUTEX_TIME_NP:这是缺省值，也就是普通锁，当一个线程加锁后，其余请求锁的线程将会形成一个等待队列，并且解锁后按照优先级获得到锁。这种策略可以
确保资源分配的公平性。
       2. PTHREAD_MUTEX_RECURSIVE_NP:嵌套锁，允许同一个线程对同一个锁获取多次，并通过unlock解锁，如果是不同的线程请求，则在加锁线程解锁时
重新进行竞争。
       3. PTHREAD_MUTEX_ERRORCHECK_NP:检错锁，如果一个线程请求同一个锁，则返回EDEADLK，否则与第一种情况是相同的。这样就保证了当允许多次加锁
时，不会出现最简单的死锁。
       4. PTHREAD_MUTEX_ADAPTIVE_NP：适应锁，动作最简单的锁， 仅仅等待解锁后重新竞争。
2. java 锁
   1. 在JDK 1.5 之前，若想实现同步，只能通过Synchronized 关键字者一种方式来达成，底层java也是通过Synchronized关键字，来做到数据的原子性的手段，
   Synchronized关键字是JVM实现的内置锁，从底层角度来说，这种锁的获取与释放都是由JVM底层帮助我们实现的。 
   2. 从JDK1.5 开始， 并发包引入了Lock锁，Lock锁的同步是基于Java来实现的。所以锁的获取与释放都是由java代码实现与控制的。然而synchronize关键字
   是基于底层操作系统的mutex来实现的。每次对锁的获取与释放动作都会带来用户态与内核态的切换。这种切换会极大的增加系统的负担。当并发两较高时， 锁的竞争比较激烈时，
   synchronized关键字的表现非常差。
   3. 从JDK1.6 开始，synchronized关键字产生了很大的变化，JVM  引入了相应的优化，来提升synchronized关键字来提升锁的性能，这种锁的提升涉及到了
   偏向锁和轻量级锁和重量级锁。从而减少锁的竞争带了用户态和内核态的切换。这种锁的优化实际上是通过java对象头中的一些标识位来实现的。 对于锁的访问和改变
   实际上都与java对象头息息相关。
   4. 从jdk 1.6 开始 java 对象在堆中会被划分为三个组成部分，对象头，实例数据， 对齐填充。 
      1. 对象头主要由三个部分组成
         1. Mark word： 其中mark word（它记录了对象，锁以及垃圾回收的信息，在64位的jvm中） 的位信息包含了如下做成部分
            1. 无锁标记
            2. 偏向锁标记
            3. 轻量级锁标记
            4. 重量级锁标记
            5. 垃圾回收标记 
         2. 指向类的指针
         3. 数组长度
   5. 对于synchronize锁来说，锁的升级主要通过Mark word 中的锁标志位 与是否是偏向锁标识位来达成的，synchronize关键字所对应的锁都是从偏向锁开始，
逐渐升级到轻量级锁， 最后升级到重量级锁。 
   6. 锁的演化
      1. 无锁->偏向锁->轻量级锁->重量级锁
   7. 偏向锁
      1. 针对一个线程来说， 他的主要作用就是优化同一个线程多次获取同一个锁的情况，如果Synchronize的方法被同一个线程访问，那么这个方法所在的对象
就会在其markdown word中将偏向锁标记进行标记，同时还会有一个字段来记录线程的id。 当这个线程再次访问同一个synchronized方法的时候。他会检查这个对象
的mark word 的偏向锁标记，以及是否指向了其线程id， 如果是的话，那么该线程就无需在入管程（monitor），而是直接进入到该方法体中。
      2. 如果是另外一个线程访问synchronize的方法： 偏向锁就会被取消掉。  
   8. 轻量级锁
      1. 若一个线程已经获得了当前对象的锁，这时第二个线程 又开始尝试争抢该对象锁，由于对象的锁已经被第一个线程 获取到一次，他是偏向锁，而第二个线程
在争抢时， 会发现该对象的Mark word已经是偏向锁， 但里面存储的线程id并不是自己，那么他会进行cas（compare and swap），从而获取到锁，这里面存在两种情况。
         1. 获取锁成功， 他们他会直接将mark word 中的线程id由第一个线程变成自己（偏向锁标记位保持不变）。这样该对象依然会保持偏向锁的状态。
         2. 获取锁失败，则表示这是可能会有多个线程同时在尝试争抢该对象的锁。那么这是偏向锁会进行升级，升级为轻量级锁。
   9. 自旋锁
      1. 如果自旋失败，那么锁就会转为位重量级锁，在这种情况下，无法获取到锁的线程都会进入到Monitor。
      2. 自旋的最大特点就是避免了线程从用户态进入了内核态 
   10. 重量级锁
       1. 线程最终从用户态进入了内核态。 
3. 编译器对锁的优化措施
   1. 锁消除技术
      1. JIT 编译器（just in time 编译器）可以在动态编译同步代码时，使用一种叫逃逸分析的技术，通过该项技术判别程序中使用的锁对象是否只被一个线程锁使用，
而没有散步道其他线程当中。如果情况就是这样的话，那么jit 编译器在编译这个同步代码时，就不会生成Synchronized关键字所标识的锁的申请与释放机器码。从而锁使用的流程。
例如下面这段代码， 由于锁对象是局部变量，所以只有一个线程使用。那么他就是会jit 编译器锁优化。
   ``` java 
      private void test(){
          Object lock = new Object();
          synchronieze(lock){
          
          }
      }
   ```
   2. 锁粗化
      1. 尽量把锁的范围扩大，JIT 在执行动态编译时，若发现前后相邻的Synchronized块儿使用的是同一个锁对象。那么他就会把这几个Synchronized块儿合并为
一个较大的同步块儿。 这样做的好处在于线程在执行这些代码时，就无需频繁申请和释放锁。从而达到申请于释放一次，就可以执行完全部的同步代码块。从而提升性能。
     ``` java 
      Object lock = new Object();
      private void test(){
          
          synchronieze(lock){
          
          }
          synchronieze(lock){
          
          }
          synchronieze(lock){
          
          }
          synchronieze(lock){
          
          }
      }
   ```
#### 死锁&活锁&饿死
1. 死锁定义：线程1等待线程2 互斥持有的资源，而线程2 也等待线程1 互斥持有的资源两个线程都无法继续执行。
2. 活锁定义：线程持续重试一个总是失败的操作，导致无法继续执行
3. 饿死定义：线程一直被调度器延迟访问其赖以执行的资源，也许是调度器先于低优先级的线程而执行高优先级的线程，同时总会有一个高优先级的线程可以执行，
饿死也叫做无限延迟
4. 监视死锁工具： jvisualvm，（jps+jstack）